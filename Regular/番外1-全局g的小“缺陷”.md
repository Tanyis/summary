## 正则表达式 g 全局匹配的弄巧成拙

当我们写好匹配规则后，利用`test()`进行验证时，你会发现第一次匹配出现为 `true` ，第二次就是 `false`，之后反复。

例如下面的情况
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191012112804404.png)

**我们从正则表达式的使用方式开始说的起**

## 正则的使用方式
 **第一种（正则表达式对象的方法）**
* exec(str) : 检索字符串中指定的值。返回找到的值，并确定其位置
* test(str) : 检索字符串中指定的值。返回 true 或 false

 **第二种（正则表达式对象的方法）**
* match(regexp) : 找到一个或多个正则表达式的匹配
* replace(regexp) : 替换与正则表达式匹配的子串
* search(regexp) : 检索与正则表达式相匹配的值
* split(search) : 把字符串分割为字符串数组

## 正则表达式的lastIndex属性

**lastIndex	下一个匹配的索引值。（这个属性只有在使用g参数时可用）**

```
该属性是可读可写的
```

如果上次匹配的结果是由方法 RegExp.exec( ) 和 RegExp.test( ) 找到的，它们就会以 lastIndex 属性所指的位置作为下次检索的起始点。

既然已经知道这个东西的形成原因，那么解决起来就非常简单了。

## 两次相同的正则匹配返回true 和 false的解决方法
**第一种**

将全局匹配去掉，例如 `/ab{3}/g` 改造成 `/ab{3}/`

**第二种**

在希望保留`全局匹配g`的情况下，我们需要手动去调整每次匹配后lastIndex的位置

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191012115413307.png)
即在第二次匹配（用到lastIndex）之前将它归零