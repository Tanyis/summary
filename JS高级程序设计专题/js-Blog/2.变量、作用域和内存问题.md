# 变量、作用域和内存问题
 1. 理解 **基本类型** 和 **引用类型** 的值
 2. 理解执行环境
 3. 理解垃圾收集
 
 ## 1.1 基本类型 和 引用类型 的值
 
 - 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
上一篇文章[1.]()提到**5种**基本数据类型:Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。
 - 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。
在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

### 1.1.1 动态的属性
定义基本类型值和引用类型值的方式是类似的————创建一个变量，并为该变量赋值。但是，当这个值保存到变量之后，对不同类型值可以执行的操作却不相同。
对于饮用类型的值，我们可以为期添加属性和方法，也可以改变和删除其属性和方法。
请看下面的例子：
```js
var person = new Object()
person.age = 21;
console.log(person.age) // 22
```
但是我们不能给基本类型的值添加属性

### 1.1.2 复制变量值
除了保存的方式不同之外，从一个变量向另一个变量复制基本类型值和引用类型值时，也存在差异。
如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制带新变量分配的位置上。
来看下面的例子：
```js
var num1 = 5;
var num2 = num1;
```
此时 **num1**中保存的是5，**num2**中也保存了5，但两个变量完全独立，他们经过的操作不会对双方进行影响。

<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-1.jpg" alt="" width="300px">

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上是引用的同一个对象，因此，改变其中一个，对另一个也会产生影响。
```js
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "jbj";
console.log(obj.name) //jbj
```
<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-2.jpg" alt="" width="300px">

### 1.1.3 传递参数

ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一个性质。基本类型的传递如同基本类型的复制一样，而引用类型的传递也如同引用类型的复制一样。

```js
function addTen (num) {
  num += 10;
  return num;
}
var count = 10;
var res = addTen(count);
console.log(cou); //10 函数的操作对外部的变量没有产生影响
console.log(res); //20
```
**如果num是按引用传递的话，那么变量count的值也将变成30。**
我们在看下面的例子：
```js
function setName(obj) {
  obj.name = "jbj";
}
var person = new Object();
setName(person)
console.log(person.name) // jbj
```
