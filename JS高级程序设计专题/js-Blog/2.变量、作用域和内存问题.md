# 变量、作用域和内存问题
 1. 理解 **基本类型** 和 **引用类型** 的值
 2. 理解执行环境
 3. 理解垃圾收集
 
 ## 1.1 基本类型 和 引用类型 的值
 
 - 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
上一篇文章[1.]()提到**5种**基本数据类型:Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。
 - 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。
在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

### 1.1.1 动态的属性
定义基本类型值和引用类型值的方式是类似的————创建一个变量，并为该变量赋值。但是，当这个值保存到变量之后，对不同类型值可以执行的操作却不相同。
对于饮用类型的值，我们可以为期添加属性和方法，也可以改变和删除其属性和方法。
请看下面的例子：
```js
var person = new Object()
person.age = 21;
console.log(person.age) // 22
```
但是我们不能给基本类型的值添加属性

### 1.1.2 复制变量值
除了保存的方式不同之外，从一个变量向另一个变量复制基本类型值和引用类型值时，也存在差异。
如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制带新变量分配的位置上。
来看下面的例子：
```js
var num1 = 5;
var num2 = num1;
```
此时 **num1**中保存的是5，**num2**中也保存了5，但两个变量完全独立，他们经过的操作不会对双方进行影响。

<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-1.jpg" alt="" width="300px">

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上是引用的同一个对象，因此，改变其中一个，对另一个也会产生影响。
```js
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "jbj";
console.log(obj.name) //jbj
```
<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-2.jpg" alt="" width="300px">

### 1.1.3 传递参数

ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一个性质。基本类型的传递如同基本类型的复制一样，而引用类型的传递也如同引用类型的复制一样。

```js
function addTen (num) {
  num += 10;
  return num;
}
var count = 10;
var res = addTen(count);
console.log(cou); //10 函数的操作对外部的变量没有产生影响
console.log(res); //20
```
**如果num是按引用传递的话，那么变量count的值也将变成30。**
我们在看下面的例子：
```js
function setName(obj) {
  obj.name = "jbj";
}
var person = new Object();
setName(person)
console.log(person.name) // jbj
```
**请注意** 很多人认为在 在局部作用域中修改的对象会在全局作用域中反映出来,就说明**参数**是按引用传递的。为了证明对象是按值传递的，我们在看一下下面的例子。
```js
function setName (obj) {
    obj.name = "jbj";
    obj = new Object(); //新添加
    obj.name = "Jace" //新添加
}
var person = new Object();
setName(person);
console.log(person.name);  // jbj
```

这个例子与前一个例子的区别是添加了两行代码，我们将一个新对象复制给变量obj，同时将其name属性设置为jace，但是我们在外层访问是，person.name仍是jbj，
这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变，实际上，当在函数内部重写obj时，这个变量引用的就是一个局部变量了。而这个局部对象会在函数执行完毕后立即被销毁。

### 1.1.4 检测类型

> 要检测一个变量是不是基本数据类型？ 目前看来 typeof 操作符是最佳的工具。说得更具体一点，typeof操作符是确定一个变量 是**字符串、数值、布尔值、还是undefined的最佳工具**。如果变量的值是一个对象或者是null，则typeof操作符会像下面例子中所示的那样返回object。

```js
let a = "jbj", b = 11 , c = true, d = null, e, f = new Object();
let arr = [a,b,c,d,e,f];
typeShow = (state) => {
    return typeof(state)
};
for(let i = 0; i < arr.length; i++){
    console.log( typeShow(arr[i]) )
}
```

<img src="https://raw.githubusercontent.com/webbj97/summary/master/JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/js-Image/2-2.jpg" alt="" width="300px">




