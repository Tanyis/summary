# 执行环境及作用域

  - 执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的**变量对象（VO）**，
环境中定义的所有变量和函数都保存在这个变量中，我们编写的代码无法访问这个对昂，但解析器会使用它。

- 每个环境都有自己的**执行环境**，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

- 当代码在一个环境中执行时，会创建**变量对象**的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。
如果这个环境是函数，则将其 **活动对象(AO)** 作为变量对象。

- 活动对象在最开始时只包含一个变量，即 arguments 对象(这个对象在全局环境中是不存在的)。作用域链中 的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。
这样，一直延 续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。

```js
    var color = "blue";
    function changeColor(){
        var anotherColor = "red";
        function swapColors(){
            var tempColor = anotherColor;
            anotherColor = color;
            color = tempColor;
            // 这里可以访问color、anotherColor和tempColor 
        }
        // 这里可以访问color和anotherColor，但不能访问tempColor
        swapColors();
    }
    // 这里只能访问color 
    changeColor();
```
以上代码共涉及 3 个执行环境:
1. 全局环境: 全局环境中有一个变量 color 和一个函数 changeColor()
2. changeColor()的局部环境: changeColor()的局部环境中有 一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变 量 color
3. swapColors()的局部环境: swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。 

无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部 则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。
如图：

