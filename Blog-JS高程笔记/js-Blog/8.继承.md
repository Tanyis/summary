# 继承

> 和其编程语言不同，ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链 来实现的。

## 1.1原型链

ECMAScript 中描述了原型链的概念，并将**原型链**作为实现继承的主要方法。
- 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
- 简单回顾一下构造函数、原型和实例的关系:
  * 每个构造函数都有一个原型对象
  * 原型对象都包含一个指向构造函数的指针
  * 实例都包含一个指向原型对象的内部指针。
- 假如我们让原型对象等于另一个类型的实例，结果会怎么样呢?
  * 显然，此时的原型对象将包含一个指向另一个原型的指针
  * 相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。
- 假如另一个原型又是另一个类型的实例
  * 那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。
  * 这就是所谓原型链的基本概念。
  
```js
 function SuperType(){
        this.property = true;
}

SuperType.prototype.getSuperValue = function(){
    return this.property;
};

function SubType(){
    this.subproperty = false;
}

//继承了 SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function (){
    return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
```

以上代码定义了两个类型:SuperType 和 SubType。每个类型分别有一个属性和一个方法。
- 它们的主要区别是 SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。
- 实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。
- 在确立了 继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上又添加了一个新方法。

这个例子中的实例以及构造函数和原型之间的关系如图所示：

<img src="https://raw.githubusercontent.com/webbj97/summary/master/Blog-JS%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0/js-Image/8-1.jpg" width="600px">


### 确定原型和实例的关系

- 可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 instanceof 操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码就说明了这 一点。

```js
alert(instance instanceof Object);  //true
alert(instance instanceof SuperType);  //true
alert(instance instanceof SubType);  //true
```

- 第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true，如下所示。

```js
alert(Object.prototype.isPrototypeOf(instance));  //true
alert(SuperType.prototype.isPrototypeOf(instance));  //true
alert(SubType.prototype.isPrototypeOf(instance));  //true
```

## 2.1借用构造函数

```js
function Super (){
  this.color = ['red','blue','green']
}

function Small() {
  Super.call(this)
}

var instance = new Small()

console.log(instance.color,"before");
instance.color.push("12345");
console.log(instance.color,"after");

```
通过使用 call()方法(或 apply()方法 也可以)，我们实际上是在(未来将要)新创建的 small 实例的环境下调用了 Super 构造函数。 这样一来，就会在新 Small 对象上执行 Super()函数中定义的所有对象初始化代码。结果， Small 的每个实例就都会具有自己的 colors 属性的副本了。

### 2.2 传递参数

相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数。看下面这个例子。
 function SuperType(name){
    this.name = name;
}
function SubType(){
//继承了 SuperType，同时还传递了参数 SuperType.call(this, "Nicholas");
//实例属性
    this.age = 29;
}
var instance = new SubType();
alert(instance.name);    //"Nicholas";
alert(instance.age);     //29
 



